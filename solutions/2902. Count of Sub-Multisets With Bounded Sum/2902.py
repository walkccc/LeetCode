class Solution:
  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of submultisets of `nums` with sum i
    dp = [1] + [0] * r
    count = collections.Counter(nums)
    zeros = count.pop(0, 0)

    for num, freq in count.items():
      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...
      stride = dp.copy()
      for i in range(num, r + 1):
        stride[i] += stride[i - num]
      for i in range(r, 0, -1):
        if i >= num * (freq + 1):
          # dp[i] + dp[i - num] + dp[i - freq * num]
          dp[i] = stride[i] - stride[i - num * (freq + 1)]
        else:
          dp[i] = stride[i]

    return (zeros + 1) * sum(dp[l:r + 1]) % kMod
